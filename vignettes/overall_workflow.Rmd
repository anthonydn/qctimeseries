---
title: "Workflow for qctimeseries"
output:
  rmarkdown::html_vignette:
    df_print: paged
vignette: |
  %\VignetteIndexEntry{Workflow for qctimeseries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval     = interactive(),
  comment  = "#>",
  collapse = TRUE, message = FALSE, warning = FALSE
)
```

## Quick demo

```{r eval=FALSE}
library(qctimeseries)

# Try the app on the included example data
getwd()
load(system.file("extdata", "ibutton_example_qc.RData", package = "qctimeseries"))

qc_progress(ibutton_example_qc, hide_complete = FALSE)

ibutton_example_qc <- qc_window_app(ibutton_example_qc, 
  y_col = "temp", time_col = "datetime", win_hrs = 10000)
# nuke those high temps when the ibutton was taken back to the lab!
```

## Overview

This vignette shows the end‑to‑end workflow for window‑by‑window QC of large time‑series:

1. **Import your own data** as a data frame with a time column and numeric variables.
2. **Initialize flag columns** with `qc_add_flags()`.
3. **Review & flag** values interactively with `qc_window_app()`.
4. **Save progress** to disk regularly (recommended each variable).
5. **Summarize progress** with `qc_progress()`.
6. **(Optional) Visual check** with `qc_check_plot()`.
7. **Apply flags** and **export** cleaned data.

**Flag encoding**: `1 = approved`, `0 = unchecked`, `-1 = original NA`, `-2 = manual flag`.

### Data requirements

* A data frame or data.table.
* One time column (default name: `"DateTime"`), of class **POSIXct**.
* One or more **numeric** variables to QC (each will get a `*_qcflag` column).

If your time column isn’t POSIXct, the app will show an error. The user should
ensure the time column is in proper format and it should not have NA values for time.

---

## 0) Install the package (first time only)

```{r eval=FALSE}
# install.packages("remotes")

# minimal (fastest; user manual vignette available online; link below)
remotes::install_github("anthonydn/qctimeseries")

# full (allows access to vignette locally)
remotes::install_github("anthonydn/qctimeseries", build_vignettes = TRUE)

# Note: You may see a warning about Rtools on Windows. This package is pure R and does
# not require compilation, so you can ignore that message.
```

---

## 1) Start or resume a session

You can **resume** from prior work, or **import new data** with your own source file.

### A. Resume work

```{r}
# Loads an R object you saved earlier (see Section 5)
# This should create an object like `ibutton_example_qc` in your workspace
# load("ibutton_example_qc.RData")
```

### B. Import new data

A .csv example with online data is shown, but any import function (e.g., read_excel) can be used as you set up.

**CSV example**

```{r, eval=FALSE}
ibutton_example <- read.csv(
  "https://raw.githubusercontent.com/anthonydn/snowmelt_belowground/master/data/ibuttons.csv")

# subset rows
ibutton_example <- ibutton_example[
  ibutton_example$block == 1 &
  ibutton_example$treatment == "C.N" &
  ibutton_example$tussock == "I",]

# convert datetime to POSIXct
ibutton_example$datetime <- as.POSIXct(ibutton_example$datetime)

# keep only the columns you want
ibutton_example <- ibutton_example[, c("datetime", "temp")]
```

**Add QC flags**

Next, add QC flags for the variables you plan to review. Choose variables using the `vars` argument. In this example, there is only one, but you can choose multiple with `vars = c("var1", "var2")`, etc. The default is all numeric variables.

```{r, eval=FALSE}
ibutton_example_qc <- qc_add_flags(ibutton_example, vars = "temp")
```

---

## 2) Assess data checking progress

`qc_progress()` reports per‑variable completion. Use `hide_complete = TRUE` to focus on what remains.

```{r, eval=FALSE}
qc_progress(ibutton_example_qc, hide_complete = FALSE)
```

Pick any variable with `pct_checked < 100`, then proceed to the app.

---

## 3) Review & flag each variable

`qc_window_app()` opens an interactive plotly graphical environment. 
Explanations of plotly graphical controls and the buttons and navigation are 
at the bottom of this document, after step 6.

```{r, eval=FALSE}
# Change y_col to the variable you are about to check
ibutton_example_qc <- qc_window_app(ibutton_example_qc, time_col = "datetime",
  y_col   = "temp", # <- EDIT THIS
  win_hrs = 10000) # default is 168 (one-week windows)
```

> The app **returns** the entire data frame when you click **Done / Return**, with the `temp_qcflag` column updated in place. Thus to record work done in the app, it must be assigned to an object, typically the same as the input data frame, but it could also be a new copy like `ibutton_example_qc_copy`

**Tip:** it’s common to work through variables one by one: run the app, finish a variable, save (next section), then move to the next variable.

**Warning:** When you hide flagged variables, they can still sometimes have flags changed if for example you click "Reset Window → Unchecked" thus it is a good idea to turn them back on to check before you are done working on that window.

---

## 4) Save progress (recommended after each window app session)

Save after each variable and before quitting RStudio, so you can resume later.

```{r, eval=FALSE}
save(ibutton_example_qc, file = "ibutton_example_qc.RData")
```

Next session, `load("ibutton_example_qc.RData")` and continue.

---

## 5) Optional: Visual overview of a cleaned series

```{r, eval=FALSE}
qc_check_plot(ibutton_example_qc, "temp", time_col = "DateTime")
```

---

## 6) Apply flags and export cleaned data

When you’re done, mask flagged values (set to `NA`) and, if you like, drop flag columns.

```{r, eval=FALSE}
ib_clean <- qc_apply_flags(ibutton_example_qc, drop_flags = TRUE)
```

**Export**

In addition to exporting the clean data, you can export the qc object to
preserve the raw data and keep a record of assigned flags.

CSV (always available):

```{r, eval=FALSE}
write.csv(ibutton_example_qc, "ibutton_qc.csv", row.names = FALSE)
write.csv(ib_clean, "ibutton_clean.csv", row.names = FALSE)
```

Excel

```{r, eval=FALSE}
# Example with writexl package
# install.packages("writexl")
writexl::write_xlsx(ibutton_example_qc, "ibutton_qc.xlsx")
writexl::write_xlsx(ib_clean, "ibutton_clean.xlsx")
```

---

## Plotly controls (modebar) used in the app

> Note: the app removes Plotly’s **Autoscale** and **Reset axes** buttons. Use the app’s **Home zoom** button to restore the default x‑range for the current window.

| Button (icon)        | What it does                                                  |
| -------------------- | ------------------------------------------------------------- |
| Pan                  | Drag to move along x/y without changing zoom.                 |
| Zoom                 | Drag to draw a zoom box on x/y.                               |
| Box Select           | Select points in a rectangle (used for flag/approve actions). |
| Lasso Select         | Freehand select points.                                       |
| Zoom In / Zoom Out   | Incremental zoom.                                             |
| Toggle Spike Lines   | Show crosshair spikes on hover.                               |
| Download plot as PNG | Save the current view as a PNG image.                         |

Selections you make (box/lasso) drive the **Flag/Approve Selected** buttons.

---

## App controls (buttons & inputs)

> Selections are made with Plotly **Box Select** or **Lasso Select** tools; the “Selected” actions below operate on those points.

<style>
.qc-controls table { table-layout: fixed; width: 100%; }
.qc-controls th:first-child { width: 30%; }
.qc-controls td, .qc-controls th { white-space: normal; word-break: break-word; }
</style>

<table class="qc-controls">
<thead><tr><th>Control</th><th>What it does</th></tr></thead><tbody><tr><td><strong>
  Prev / Next
</strong></td><td>
  Move to the previous/next time window.

</td></tr><tr><td><strong>
  Window number box
</strong></td><td>
  Displays current window. Target window numbers can also be entered.

</td></tr><tr><td><strong>
  Flag Selected &amp; Approve Unflagged &amp; Next ➜ (Blue)
</strong></td><td>
  Flag selected points (<code>-2</code>), approve all other <strong>unchecked &amp; non-missing</strong> points in the current window (<code>1</code>), then advance to the next window. This is the workhorse button and is built for speedy checking. If the window looks good, click it. If there are a couple bad points, you can select them with box or lasso and then click it to flag those and go to the next. It will not reverse any already flagged points.

</td></tr><tr><td><strong>
  Home zoom
</strong></td><td>
  Restore the default x-range for the current window and re-autoscale y.

</td></tr><tr><td><strong>
  Secondary (dropdown)
</strong></td><td>
  Display a secondary variable (orange line) beneath the main plot; respects <strong>Hide flagged</strong>.
</td></tr>

<tr><td><strong>
  Flag Selected Points
</strong></td><td>
  Set selected points’ flag to <code>-2</code> (manual flag).

</td></tr><tr><td><strong>
  Unflag Selected Points
</strong></td><td>
  Set selected points’ flag to <code>0</code> (unchecked).
</td></tr>

<tr><td><strong>
  Approve Selected Points
</strong></td><td>
  Set selected points’ flag to <code>1</code> (approved).

</td></tr><tr><td><strong>
  Flag ENTIRE Window
</strong></td><td>
  Set <strong>all</strong> rows in the current window to <code>-2</code>.
</td></tr>

<tr><td><strong>
  Approve ALL Unflagged
</strong></td><td>
  Set <strong>unchecked &amp; non-missing</strong> rows in the current window to <code>1</code>.

</td></tr><tr><td><strong>
  Reset Window → Unchecked
</strong></td><td>
  Set all rows’ flags in the window to <code>0</code> (original NAs remain <code>-1</code>).

</td></tr><tr><td><strong>
  Hide flagged (red)
</strong></td><td>
  Hide flagged points on the primary plot; secondary plot also omits flagged rows.

</td></tr><tr><td><strong>
  Window (hrs)
</strong></td><td>
  Re-define window width (hours) and recompute windowing.

</td></tr><tr><td><strong>
  Reset ALL → Unchecked
</strong></td><td>
  Set <strong>all</strong> flags to <code>0</code> except original NAs (<code>-1</code>).

</td></tr><tr><td><strong>
  Done / Return
</strong></td><td>
  Close the app and return the entire data frame with updated <code>*_qcflag</code> for the active <code>y_col</code>.
</td></tr>

</tbody>
</table>

---

## Hotkeys

<style> .qc-hotkeys table { table-layout: fixed; width: 100%; } .qc-hotkeys th:first-child { width: 28%; } .qc-hotkeys td, .qc-hotkeys th { white-space: normal; word-break: break-word; } </style> <table class="qc-hotkeys"> <thead> <tr><th>Hotkey</th><th>What it does</th><th>Notes</th></tr> </thead> <tbody> <tr> <td><strong>Space</strong> (hold)</td> <td>Temporarily switch to <strong>Pan</strong></td> <td>Convenient for quick drags; keys aren’t captured while typing in inputs</td> </tr> <tr> <td><strong>B</strong></td> <td>Set drag mode to <strong>Box Select</strong></td> <td>Use to select points in a rectangle</td> </tr> <tr> <td><strong>Q</strong> or <strong>L</strong></td> <td>Set drag mode to <strong>Lasso Select</strong></td> <td>Freeform selection</td> </tr> <tr> <td><strong>Z</strong></td> <td>Set drag mode to <strong>Zoom</strong></td> <td>Drag to zoom, double-click to autoscale y</td> </tr> <tr> <td><strong>P</strong></td> <td>Set drag mode to <strong>Pan</strong></td> <td>Click-drag to move along the time axis</td> </tr> <tr> <td><strong>H</strong></td> <td><strong>Home zoom</strong></td> <td>Restore default x-range for current window and autoscale y</td> </tr> <tr> <td><strong>←</strong> Left Arrow</td> <td><strong>Prev</strong> window</td> <td>Same as clicking <em>Prev</em></td> </tr> <tr> <td><strong>→</strong> Right Arrow</td> <td><strong>Next</strong> window</td> <td>Same as clicking <em>Next</em></td> </tr> <tr> <td><strong>Enter</strong></td> <td><strong>Flag Selected &amp; Approve Unflagged &amp; Next</strong></td> <td>Workhorse action; advances to next window</td> </tr> </tbody> </table>

---

## Summary of Workflow

```{r summary}
# 1. Import
data <- read.csv("path/to/input.csv", stringsAsFactors = FALSE)
data$DateTime <- as.POSIXct(data$DateTime, tz = "UTC")

# 2. Add QC flags
vars_to_qc <- c("temp", "hum")
data_qc <- qc_add_flags(data, vars = vars_to_qc)

# 3. Work variable by variable
data_qc <- qc_window_app(data_qc, y_col = "temp", time_col = "DateTime")
save(data_qc, file = "data_qc.RData")

# 4. Progress and optional plot
qc_progress(data_qc, hide_complete = TRUE)
# qc_check_plot(data_qc, "temp", time_col = "DateTime")

# 5. Apply and export
data_clean <- qc_apply_flags(data_qc, drop_flags = TRUE)
write.csv(data_qc, "data_qc.csv", row.names = FALSE)
write.csv(data_clean, "data_clean.csv", row.names = FALSE)
```

## Helper mode for non-R users (R Markdown template)

You can set up a simple QC environment so helpers with little to no R experience can review data by opening an editable R Markdown file and pressing "Run" on each chunk. The only thing they change is the variable name as they move through each variable that needs QC checking.

### One-time prep by an analyst

```{r, eval=FALSE}
# 1) Import your data and add QC flags
dat <- read.csv("your_data.csv")  # or readxl::read_excel(...)
dat_qc <- qctimeseries::qc_add_flags(dat) # adds *_qcflag columns

# 2) Save the working object for checkers
save(dat_qc, file = "your_data_qc.RData")
```

### Create the checker document in the same folder as the saved .Rdata file

```{r, eval=FALSE}
# Via Rstudio Menu:
# File -> New File -> R Markdown -> From Template -> "Data checker - qctimeseries"
# Give it a name you want like your_data_checker and select the folder
# you want it in

# Or create directly in your working directory:
rmarkdown::draft("your_data_checker.Rmd",
  template = "data-checker", package = "qctimeseries")
```

### What the template does

* Loads a working object (example: `ibutton_example_qc.RData`; substitute your own file).
* Shows QC progress with `qc_progress()`.
* Launches the windowed app with `qc_window_app()`.
* Saves work with `save(...)` so progress persists between sessions.
